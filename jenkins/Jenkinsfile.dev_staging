pipeline {
    agent any

    tools {
        git 'Default'
    }

    options {
        skipDefaultCheckout(true)
    }

    environment {
        // Monorepo URLs
        DEV_REPO_URL       = 'https://github.com/Tondeptrai23/spring-petclinic-microservices.git'

        // DockerHub credentials for pushing images
        DOCKERHUB_CREDENTIALS_ID = 'dockerhub-secret'
        DOCKERHUB_NAMESPACE      = 'mikenam'   // ← your Docker Hub user/org
    }

    stages {
        stage('Checkout Config Repo') {
            steps {
                dir('config-repo') {
                    git url: 'https://github.com/Tondeptrai23/spring-petclinic-config.git',
                        branch: 'main',
                        changelog: false,
                        poll: false
                }
            }
        }

        stage('Checkout Source') {
            steps {
                // always clone the full dev repo
                dir('dev-repo') {
                    git url: env.DEV_REPO_URL,
                        branch: 'main',
                        changelog: false,
                        poll: false
                    sh 'git fetch --all --prune --quiet'
                }
            }
        }

        stage('Decide Tag & Namespace') {
            steps {
                script {
                    // Jenkins sets GIT_BRANCH="refs/heads/main" or "refs/tags/vX.Y.Z"
                    def ref = env.GIT_BRANCH ?: ''
                    if (ref.startsWith('refs/tags/')) {
                        // we’re building a tag
                        env.EFFECTIVE_TAG    = ref.replaceFirst('refs/tags/', '')
                        env.TARGET_NAMESPACE = 'staging'
                    }
                    else if (ref == 'refs/heads/main') {
                        // plain main branch
                        env.EFFECTIVE_TAG    = 'latest'
                        env.TARGET_NAMESPACE = 'dev'
                    }
                    else {
                        error("Unsupported ref '${ref}'. Only 'main' or tags 'vX.Y.Z' are allowed.")
                    }
                    echo "→ Using image tag   : ${env.EFFECTIVE_TAG}"
                    echo "→ Deploying to      : ${env.TARGET_NAMESPACE}"
                }
            }
        }

        stage('Build & Push Docker Images') {
            steps {
                script {
                    // list of services (must match sub-dirs in dev-repo)
                    def SERVICES = [
                        'config-server',
                        'discovery-server',
                        'api-gateway',
                        'customers-service',
                        'vets-service',
                        'visits-service'
                    ]

                    // log in and push all services
                    docker.withRegistry('', env.DOCKERHUB_CREDENTIALS_ID) {
                        SERVICES.each { svc ->
                            def imageName = "${env.DOCKERHUB_NAMESPACE}/${svc}:${env.EFFECTIVE_TAG}"
                            echo "Building ${imageName}..."
                            docker.build(imageName, "dev-repo/${svc}")
                            echo "Pushing ${imageName}..."
                            docker.push(imageName)
                        }
                    }
                }
            }
        }

        stage('Deploy with Helm') {
            steps {
                withCredentials([
                    file  (credentialsId: env.KUBECONFIG_ID, variable: 'KUBECONFIG'),
                    string(credentialsId: env.DOCKERHUB_CREDENTIALS_ID, variable: 'DOCKERHUB_SECRET')
                ]) {
                    script {
                        def chartsRoot  = 'config-repo/helm-charts/dev'
                        def ns         = env.TARGET_NAMESPACE
                        // build --set args for each service
                        def setArgs = services.collect { svc ->
                            "--set services.${svc}.tag=${env.EFFECTIVE_TAG}"
                        }.join(' ')

                        sh """
                            helm upgrade --install petclinic ${chartsRoot} \
                              --namespace ${ns} --create-namespace \
                              -f ${chartsRoot}/values.yaml \
                              --set image.pullSecrets[0].name=${DOCKERHUB_SECRET} \
                              ${setArgs}
                        """

                        if (env.TARGET_NAMESPACE == 'staging') {
                            sh """
                            kubectl apply -f config-repo/ingress-staging.yaml \
                              --namespace ${ns}
                            """
                        }
                        else if (env.TARGET_NAMESPACE == 'dev') {
                            sh """
                            kubectl apply -f config-repo/ingress-dev.yaml \
                              --namespace ${ns}
                            """
                        }
                        else {
                            error("Unsupported namespace '${ns}'. Only 'dev' or 'staging' are allowed.")
                        }
                        
                        echo "Deployment to '${ns}' completed successfully."
                    }
                }
            }
        }
    }

    post {
        success { echo "✅ Deployment to '${env.TARGET_NAMESPACE}' with tag '${env.EFFECTIVE_TAG}' succeeded." }
        failure { echo "❌ Deployment failed." }
    }
}
